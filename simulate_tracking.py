#!/usr/bin/env python

'''Functions for simulating the tracking of an object in space.


**Usage examples:**

.. code-block:: python

    import radar_library as rl
    from propagator_sgp4 import PropagatorSGP4
    
    radar=rl.eiscat_3d(beam='gauss')

    o=so.SpaceObject(
        a=7000,
        e=0.0,
        i=72,
        raan=0,
        aop=0,
        mu0=0,
        C_D=2.3,
        A=1.0,
        m=1.0,
        d=0.1,
        propagator = PropagatorSGP4,
        propagator_options = {
            'polar_motion': False,
        },
    )
    
    _t0 = time.time()
    passes = get_passes(o, radar, 0, 18.*3600., max_dpos=1e3)
    _t1=time.time()
    print("wall clock time %1.2f"%(_t1-_t0))

    print_passes(passes)

    p_id = 1

    t0, t1 = passes['t'][0][p_id]
    t = n.linspace(t0, t1, num=1000)

    scan_snr = get_scan_snr(t, o, radar)
    track_snr = get_track_snr(t, o, radar)

    fig = plt.figure(figsize=(15,15))
    ax = fig.add_subplot(211)
    ax = plot_snr(t, track_snr, radar, ax=ax)
    ax.set_title('SNR when tracking')

    ax = fig.add_subplot(212)
    ax = plot_snr(t, scan_snr, radar, ax=ax)
    ax.set_title('SNR when scanning')

    ts, angs = get_angles(passes, o, radar)
    ax = plot_angles(ts, angs)

    plt.show()



'''
import numpy as n
import scipy.constants as c
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
import h5py

# SORTS imports
import space_object as so
from propagator_sgp4 import MU_earth
import coord
import debris
import time
import plothelp
import dpt_tools as dpt


def find_linspace_num(t0, t1, a, e, max_dpos=1e3):
    '''Find the number of linearly spaced temporal positions which are sufficient to achieve a maximum spatial separation.
    Assume elliptic orbit and use the velocity at periapsis, does not take perturbation patterns into account.
    
    :param float t0: Start time in seconds
    :param float t1: End time in seconds
    :param float a: Semi-major axis in meters
    :param float max_dpos: Maximum separation between evaluation points in meters.
    :return: Number of points needed
    :rtype: int
    '''
    r = dpt.elliptic_radius(0.0, a, e, radians=True)
    v = dpt.orbital_speed(r, a, MU_earth)
    R = (t1-t0)*v
    n_points = int(R/max_dpos)
    return n_points


def print_passes(det_times):
    '''Function to pretty print detection times list returned by the :func:`simulate_tracking.get_passes` function.
        
        :param list det_times: List of dictionaries generated by get_passes.
    '''
    txc = 0
    for t,snr in zip(det_times['t'],det_times['snr']):
        print('For TX %i: %i detections' %(txc,len(t)))
        for di in range(len(t)):
            for rx in range(len(snr[di])):
                print('Detection %i: Peak snr tx%i-rx%i %.2f dB at %.2f h (pass %.2f h - %.2f h)' %(di,txc,rx,\
                    10.0*n.log10(snr[di][rx][0]),snr[di][rx][1]/3600.0, t[di][0]/3600.0,t[di][1]/3600.0))
        txc+=1

def get_scan_snr(t,o,radar):
    '''Takes a series of times, a space object and a radar system and calculates the SNR for that space object given the scan pattern of the radar over the given times.

    :param numpy.ndarray t: Times in seconds relative space object epoch over witch SNR should be evaluated.
    :param SpaceObject o: Space object to be measured.
    :param RadarSystem radar: Radar system that performs the measurement.
    :return: List of lists of numpy.ndarray's corresponding to TX antenna index, RX antenna index and SNR-array in that order of list depth.
    '''
    
    ecef=o.get_orbit(t)

    zenith_v = []
    tx_ecef = []
    rx_ecef = []
    for tx in radar._tx:
        tx_ecef.append( tx.ecef )
        zenith_v.append( coord.azel_ecef(tx.lat, tx.lon, 0.0, 0.0, 90.0) )
    for rx in radar._rx:
        rx_ecef.append( rx.ecef )
    
    postx_v = []
    posrx_v = []
    idx_v = []
    rx_dets = 0
    for rxp0 in rx_ecef:
        pos_vecs=(ecef.T-rxp0).T
        posrx_v.append(pos_vecs)

    # for each transmitter
    for txi,txp0 in enumerate(tx_ecef):
        zenith = zenith_v[txi]
        pos_vecs=(ecef.T-txp0).T
        pos_vecs0=pos_vecs/n.sqrt(pos_vecs[0,:]**2.0+pos_vecs[1,:]**2.0+pos_vecs[2,:]**2.0)

        postx_v.append(pos_vecs)


    snrs = [None]*len(radar._tx)
    for txi,tx in enumerate(radar._tx):
        snrs[txi] = [None]*len(radar._rx)
        for rxi,rx in enumerate(radar._rx):
            snr_curve = []
            for I in range(len(t)):
                tx_dist = n.linalg.norm(postx_v[txi][:,I])

                k_obj_tx = coord.ecef2local(
                    lat = tx.lat,
                    lon = tx.lon,
                    alt = tx.alt,
                    x = postx_v[txi][0,I],
                    y = postx_v[txi][1,I],
                    z = postx_v[txi][2,I],
                )
                k_obj_rx = coord.ecef2local(
                    lat = rx.lat,
                    lon = rx.lon,
                    alt = rx.alt,
                    x = posrx_v[txi][0,I],
                    y = posrx_v[txi][1,I],
                    z = posrx_v[txi][2,I],
                )

                k0=tx.get_scan(t[I]).local_pointing(t[I]) #get scan pointing
                tx.beam.point_k0(k0)
                gain_tx = tx.beam.gain(k_obj_tx)
                
                rx_dist = n.linalg.norm(posrx_v[rxi][:,I])
                
                rx.beam.point_k0(k_obj_rx)
                gain_rx = rx.beam.gain(k_obj_rx)

                snr=debris.hard_target_enr(gain_tx,
                                        gain_rx,
                                        rx.wavelength,
                                        tx.tx_power,
                                        tx_dist,
                                        rx_dist,
                                        diameter_m=o.d,
                                        bandwidth=tx.coh_int_bandwidth,
                                        rx_noise_temp=rx.rx_noise)

                snr_curve.append(snr)

            snr_curve = n.array(snr_curve)
            snrs[txi][rxi] = snr_curve
    return snrs



def get_track_snr(t,o,radar):
    '''Takes a series of times, a space object and a radar system and calculates the SNR for that space object measured by that radar over the given times.

    :param numpy.ndarray t: Times in seconds relative space object epoch over witch SNR should be evaluated.
    :param SpaceObject o: Space object to be measured.
    :param RadarSystem radar: Radar system that performs the measurement.
    :return: List of lists of numpy.ndarray's corresponding to TX antenna index, RX antenna index and SNR-array in that order of list depth.
    '''
    
    ecef=o.get_orbit(t)

    tx_ecef = []
    rx_ecef = []
    for tx in radar._tx:
        tx_ecef.append( tx.ecef )
    for rx in radar._rx:
        rx_ecef.append( rx.ecef )
    
    postx_v = []
    posrx_v = []
    for rxp0 in rx_ecef:
        pos_vecs=(ecef.T-rxp0).T
        posrx_v.append(pos_vecs)

    for txi,txp0 in enumerate(tx_ecef):
        pos_vecs=(ecef.T-txp0).T
        postx_v.append(pos_vecs)


    snrs = [None]*len(radar._tx)
    for txi,tx in enumerate(radar._tx):
        snrs[txi] = [None]*len(radar._rx)
        for rxi,rx in enumerate(radar._rx):
            snr_curve = []
            for I in range(len(t)):

                tx_dist = n.linalg.norm(postx_v[txi][:,I])
                k0 = coord.ecef2local(
                    lat = tx.lat,
                    lon = tx.lon,
                    alt = tx.alt,
                    x = postx_v[txi][0,I],
                    y = postx_v[txi][1,I],
                    z = postx_v[txi][2,I],
                )
                tx.beam.point_k0(k0)
                gain_tx = tx.beam.gain(k0)
                
                rx_dist = n.linalg.norm(posrx_v[rxi][:,I])
                # point towards object
                k0 = coord.ecef2local(
                    lat = rx.lat,
                    lon = rx.lon,
                    alt = rx.alt,
                    x = posrx_v[txi][0,I],
                    y = posrx_v[txi][1,I],
                    z = posrx_v[txi][2,I],
                )
                rx.beam.point_k0(k0)
                gain_rx = rx.beam.gain(k0)

                snr=debris.hard_target_enr(gain_tx,
                                        gain_rx,
                                        rx.wavelength,
                                        tx.tx_power,
                                        tx_dist,
                                        rx_dist,
                                        diameter_m=o.d,
                                        bandwidth=tx.coh_int_bandwidth,
                                        rx_noise_temp=rx.rx_noise)

                snr_curve.append(snr)

            snr_curve = n.array(snr_curve)
            snrs[txi][rxi] = snr_curve
    return snrs


def plot_snr(t,all_snrs,radar, ax=None):
    '''Plots the SNR's structure (list of lists of numpy.ndarray's) returned by :func:`simulate_tracking.get_track_snr` and :func:`simulate_tracking.get_scan_snr`.

    :param numpy.ndarray t: Times corresponding to the evaluated SNR's.
    :param all_snrs: List structure returned by :func:`simulate_tracking.get_track_snr` and :func:`simulate_tracking.get_scan_snr`.
    :param RadarSystem radar: Radar system that measured the SNR's.
    :param ax: matplotlib axis to plot the SNR's on. If not given, create new figure and axis.
    :return: The matplotlib axis object
    '''
    
    tv = t/3600.0
    for txi,snrs in enumerate(all_snrs):
        if ax is None:
            fig, ax = plt.subplots(len(snrs), 1, figsize=(14, 10), tight_layout=True)
        for rxi,snr in enumerate(snrs):
            ax.plot(tv, 10.0*n.log10(snr), label='SNR: {} to {}'.format(radar._tx[txi].name,radar._rx[rxi].name))
        ax.set(
            ylabel='SNR [dB]',
            xlabel='time [h]',
        )
    plt.legend()
    return ax


def find_pass_interval(t, o, radar, logger = None):
    '''Find a pass inside the FOV of a radar given a series of times for a space object.
    
    :param numpy.ndarray t: Linear vector of times to use as a base to find pass in seconds relative space object epoch.
    :param SpaceObject o: Space object to find pass interval for.
    :param RadarSystem radar: Radar system that defines the FOV.
    :return: Tuple of (passes, passes_id, idx_v, postx_v, posrx_v), description below.

    **Return data:**

        * passes: Three layers of lists where first layer is a list corresponding to every RX antenna of the radar system. Second layer is the a entry in the list for every pass. Last layer of lists is a list of two elements where the first is the time in seconds when object enters the FOV and second is the time in seconds when the object leaves the FOV.
        * passes_id: Same structure as the passes data but with the time indices's instead of the actual times.
        * idx_v: List of arrays of indices's of input time vector where the space object is inside the TX FOV, length of list is equal to the number of TX stations.
        * postx_v: list of arrays containing the position of the space object relative the TX stations, length of list is equal to number of TX stations and the array is the length of the input time vector.
        * posrx_v: list of arrays containing the position of the space object relative the RX stations, length of list is equal to number of RX stations and the array is the length of the input time vector.
    '''
    ecef = o.get_orbit(t)
    
    dt = (n.max(t) - n.min(t))/len(t)

    zenith_v = []
    tx_ecef = []
    rx_ecef = []
    for tx in radar._tx:
        tx_ecef.append( tx.ecef )
        zenith_v.append( coord.azel_ecef(tx.lat, tx.lon, 0.0, 0.0, 90.0) )
    for rx in radar._rx:
        rx_ecef.append( rx.ecef )
    

    postx_v = []
    posrx_v = []
    idx_v = []
    for rxp0 in rx_ecef:
        pos_vecs=(ecef.T-rxp0).T
        posrx_v.append(pos_vecs)

    # for each transmitter
    for txi,txp0 in enumerate(tx_ecef):
        zenith = zenith_v[txi]
        pos_vecs = (ecef.T-txp0).T
        pos_vecs0 = pos_vecs/n.sqrt(pos_vecs[0,:]**2.0+pos_vecs[1,:]**2.0+pos_vecs[2,:]**2.0)
        
        # elevation angle for transmitter
        z_angles = 180.0*n.arccos(pos_vecs0[0,:]*zenith[0]+pos_vecs0[1,:]*zenith[1]+pos_vecs0[2,:]*zenith[2])/n.pi

        # there the elevation angle is larger than elevation cutoff
        idx = n.where(z_angles < (90.0 - radar._tx[txi].el_thresh) )[0]
        postx_v.append(pos_vecs)
        idx_v.append(idx)

        if logger is not None:
            logger.debug("txi{}: idx {} ".format(txi,len(idx)))

        #remove later
        #plt.plot(z_angles)
        #plt.show()


    #find passes
    #format
    # [tx num][pass num][0 = above, 1 = below]
    passes = [None]*len(radar._tx)
    passes_id = [None]*len(radar._tx)
    for txi,idx in enumerate(idx_v):
        if len(idx) > 0:
            Tv = t[idx]
            passes[txi] = [[Tv[0]]]
            passes_id[txi] = [[0]]
            for ti in range(len(Tv)-1):
                if Tv[ti+1] - Tv[ti] > 3*dt:
                    passes[txi][-1].append(Tv[ti])
                    passes[txi].append([Tv[ti+1]])

                    passes_id[txi][-1].append(ti)
                    passes_id[txi].append([ti+1])
            passes[txi][-1].append(Tv[-1])
            passes_id[txi][-1].append(len(Tv)-1)
    
    return passes, passes_id, idx_v, postx_v, posrx_v


def get_passes(o, radar, t0, t1, max_dpos=1e3, logger = None, plot = False, t_samp = None):
    '''Follow object and determine possible maintenance track window. I.e. get all passes of the object inside the radar system FOV.
    
    :param SpaceObject o: Space object to find passes for.
    :param RadarSystem radar: Radar system that defines the FOV.
    :param float t0: Start time for passes search in seconds relative space object epoch.
    :param float t1: Stop time for passes search in seconds relative space object epoch.
    :param float max_dpos: Maximum separation in km between orbital evaluation points.
    :param Logger logger: Logger object for logging the execution of the function.
    :param float t_samp: If not None, overrides the "max_dpos" variable and fixes a time-sampling.
    :return: Dictionary containing information about all passes of the space object inside the radar system FOV.
    :rtype: dict

    **Output dictionary:**

      * t: Three layers of lists where first layer is a list corresponding to every RX antenna of the radar system. Second layer is the a entry in the list for every pass. Last layer of lists is a list of two elements where the first is the time in seconds when object enters the FOV and second is the time in seconds when the object leaves the FOV. I.e. :code:`pass_start_time = passes["t"][tx_index][pass_index][0]` and :code:`pass_end_time = passes["t"][tx_index][pass_index][1]`.
      * snr: This structure has the same format as the "t" item but with an extra layer of lists of receivers before the bottom. Then instead of the bottom layer of lists being start and stop times it records the peak SNR at the first item and the time of that peak SNR in the second item. I.e. :code:`pass_peak_snr = passes["snr"][tx_index][pass_index][rx_index][0]` and :code:`pass_peak_snr_time = passes["snr"][tx_index][pass_index][rx_index][1]`.
    '''
    pass_struct = {"t":[],"snr":[]}

    if t_samp is None:
        num_t = find_linspace_num(t0, t1, o.a*1e3, o.e, max_dpos=max_dpos)
        t=n.linspace(t0,t1,num=num_t, dtype=n.float64)
    else:
        t=n.arange(t0,t1,t_samp, dtype=n.float64)
        num_t = len(t)
    
    if logger is not None:
        logger.debug("n_points %d %1.2f"%(num_t,max_dpos))

    # time vector
    


    if logger is not None:
        date0_y,date0_m,date0_d = dpt.jd_to_date(dpt.mjd_to_jd(o.mjd0))
        logger.debug('--> Getting {} orbit location between: {:.5f} h and {:.5f} h relative {}-{}-{}'.format(
                num_t, t[0]/(3600), t[-1]/(3600), date0_y, date0_m, date0_d,
            )
        )
        
    passes, passes_id, idx_v, postx_v, posrx_v = find_pass_interval(t, o, radar, logger = logger)

    if logger is not None:
        logger.debug("passes:\n {}".format(passes))


    tx_dets = 0
    for idx in idx_v:
        if len(idx) > 0:
            tx_dets += 1
    
    if tx_dets == 0:
        if logger is not None:
            logger.debug("no passes visible from any RX station")
        return pass_struct

    if logger is not None:
        logger.debug("--> List of passes constructed")
        logger.debug("{}".format(passes))

    snrs = [None]*len(radar._tx)
    for txi,idx in enumerate(idx_v):
        if len(idx) > 0:
            snrs[txi] = [None]*len(passes[txi])
            tx = radar._tx[txi]
            for pid,pass_ids in enumerate(passes_id[txi]):
                idx_p = idx[pass_ids[0]:pass_ids[1]]


                if logger is not None:
                    logger.debug("{}".format(idx_p))
                    logger.debug("{}".format(pass_ids))

                snrs[txi][pid] = [None]*len(radar._rx)
                rx_dets = 0
                for rxi,rx in enumerate(radar._rx):
                    snr_curve = []
                    for I in idx_p:
                        tx_dist = n.linalg.norm(postx_v[txi][:,I])
                        k0 = coord.ecef2local(
                            lat = tx.lat,
                            lon = tx.lon,
                            alt = tx.alt,
                            x = postx_v[txi][0,I],
                            y = postx_v[txi][1,I],
                            z = postx_v[txi][2,I],
                        )
                        tx.beam.point_k0(k0)
                        gain_tx = tx.beam.gain(k0)
                        
                        rx_dist = n.linalg.norm(posrx_v[rxi][:,I])
                        # point towards object
                        k0 = coord.ecef2local(
                            lat = rx.lat,
                            lon = rx.lon,
                            alt = rx.alt,
                            x = posrx_v[txi][0,I],
                            y = posrx_v[txi][1,I],
                            z = posrx_v[txi][2,I],
                        )
                        rx.beam.point_k0(k0)
                        gain_rx = rx.beam.gain(k0)
                        
                        snr=debris.hard_target_enr(gain_tx,
                                                gain_rx,
                                                rx.wavelength,
                                                tx.tx_power,
                                                tx_dist,
                                                rx_dist,
                                                diameter_m=o.d,
                                                bandwidth=tx.coh_int_bandwidth,
                                                rx_noise_temp=rx.rx_noise)
                        
                        if logger is not None:
                            logger.debug('\n--> TX-d: %.2f km | TX-g: %.2f dB'%(tx_dist*1e-3,10.0*n.log10(gain_tx)))
                            logger.debug('--> RX-d: %.2f km | RX-g: %.2f dB'%(rx_dist*1e-3,10.0*n.log10(gain_rx)))
                            logger.debug('--> SNR: %.2f dB '%(10.0*n.log10(snr) ))
                        snr_curve.append(snr)

                    snr_curve = n.array(snr_curve)

                    if plot:
                        snr_curve_dB = 10.0*n.log10(snr_curve)
                        snr_curve_dB[snr_curve_dB < 0] = 0
                        plt.plot(t[idx_p],snr_curve_dB)
                        plt.plot(t[idx_p[n.argmax(snr_curve)]],n.max(snr_curve_dB),'or')
                        plt.title("tx %i, pass %i, rx %i"%(txi,pid,rxi))
                        plt.show()
                        print('SNR max: %.2f @ %.2f h'%(n.max(snr_curve_dB),t[idx_p[n.argmax(snr_curve)]]/3600.0))
                    if len(snr_curve)>0:
                        snr_max = n.max(snr_curve)
                    else:
                        snr_max=0.0
                    if snr_max >= tx.enr_thresh:
                        rx_dets+=1
                        snrs[txi][pid][rxi] = [snr_max,t[idx_p[n.argmax(snr_curve)]]]
                    else:
                        snrs[txi][pid][rxi] = [0,0]

                if rx_dets == 0:
                    snrs[txi][pid] = None

                if plot:
                    fig = plt.figure(figsize=(15,15))
                    ax = fig.add_subplot(111, projection='3d')
                    plothelp.draw_earth_grid(ax)
                    ax.plot(ecef[0,:],ecef[1,:],ecef[2,:],alpha=1,color="black")
                    for I in idx_p:
                        ax.plot([tx.ecef[0],tx.ecef[0]+postx_v[txi][0,I]],[tx.ecef[1],tx.ecef[1]+postx_v[txi][1,I]],[tx.ecef[2],tx.ecef[2]+postx_v[txi][2,I]],alpha=0.5,color="red")
                        for rxi,rx in enumerate(radar._rx):
                            ax.plot([rx.ecef[0],rx.ecef[0]+posrx_v[rxi][0,I]],[rx.ecef[1],rx.ecef[1]+posrx_v[rxi][1,I]],[rx.ecef[2],rx.ecef[2]+posrx_v[rxi][2,I]],alpha=0.5,color="red")
                    delta = 1000e3
                    ax.set_xlim([tx.ecef[0] - delta,tx.ecef[0] + delta])
                    ax.set_ylim([tx.ecef[1] - delta,tx.ecef[1] + delta])
                    ax.set_zlim([tx.ecef[2] - delta,tx.ecef[2] + delta])
                    plt.show()
            passes[txi] = [ x for ix,x in enumerate(passes[txi]) if snrs[txi][ix] is not None ] #remove tracks that were not above detection tresholds at any pair
            snrs[txi]   = [ x for x in snrs[txi] if x is not None ] #remove tracks that were not above detection tresholds at any pair
    
    for txi,tx_snr in enumerate(snrs):
        if tx_snr is None:
            snrs[txi] = []
    for txi,tx_pass in enumerate(passes):
        if tx_pass is None:
            passes[txi] = []

    pass_struct['snr'] = snrs
    pass_struct['t'] = passes

    return pass_struct

def get_angles(passes, o, radar, dt=0.1):
    '''Takes the passes structure that is output from :func:`simulate_tracking.get_passes`, the space object and the radar system and calculates the zenith angle for all passes.

    :param dict passes: Output from :func:`simulate_tracking.get_passes` that contains information about passes of an space object.
    :param SpaceObject o: Space object that made the passes.
    :param RadarSystem radar: Radar system that defines the FOV.
    :param float dt: Time step for angle evaluation.
    :return: Tuple of list of lists of times and list of lists of angles corresponding to each pass.
    '''
    zenith_v = []
    tx_ecef = []
    rx_ecef = []
    for tx in radar._tx:
        tx_ecef.append( tx.ecef )
        zenith_v.append( coord.azel_ecef(tx.lat, tx.lon, 0.0, 0.0, 90.0) )

    angs = []
    ts = []
    for txi,txp in enumerate(passes['t']):
        angs.append([])
        ts.append([])
        zenith = zenith_v[txi]
        txp0 = tx_ecef[txi]
        for ps in txp:
            t = n.arange(ps[0],ps[1],dt)
            ecef=o.get_orbit(t)

            pos_vecs=(ecef.T-txp0).T
            pos_vecs0=pos_vecs/n.sqrt(pos_vecs[0,:]**2.0+pos_vecs[1,:]**2.0+pos_vecs[2,:]**2.0)
            z_angles=180.0*n.arccos(pos_vecs0[0,:]*zenith[0]+pos_vecs0[1,:]*zenith[1]+pos_vecs0[2,:]*zenith[2])/n.pi

            angs[-1].append(z_angles)
            ts[-1].append(t)

    return ts, angs

def plot_angles(ts, angs, ax=None):
    '''Plot the angles data returned by the :func:`simulate_tracking.get_angles` function.

    :param list ts: List of times for each pass that the angles were evaluated over.
    :param list angs: List of angles for each pass.
    :param ax: matplotlib axis to plot the SNR's on. If not given, create new figure and axis.
    :return: The matplotlib axis object
    '''
    if ax is None:
        fig, ax = plt.subplots(1, 1, figsize=(14, 10), tight_layout=True)
    txc = 0
    for txt,txa in zip(ts,angs):
        psc = 0
        for pst,psa in zip(txt,txa):
            tv = n.array(pst)/60.0
            ax.plot(tv - tv[0], n.array(psa),label='TX{} - pass {}'.format(txc,psc))
            psc+=1
        txc+=1
    ax.set( \
        title='passes Angles', \
        ylabel='Zenith angle [deg]', \
        xlabel='Time since entering FOV [min]')
    plt.legend()
    return ax



if __name__ == "__main__":
    import radar_library as rl
    from propagator_sgp4 import PropagatorSGP4
    
    radar=rl.eiscat_3d(beam='gauss')

    o=so.SpaceObject(
        a=7000,
        e=0.0,
        i=72,
        raan=0,
        aop=0,
        mu0=0,
        C_D=2.3,
        A=1.0,
        m=1.0,
        d=0.1,
        propagator = PropagatorSGP4,
        propagator_options = {
            'polar_motion': False,
        },
    )
    
    _t0 = time.time()
    passes = get_passes(o, radar, 0, 18.*3600., max_dpos=1e3)
    _t1=time.time()
    print("wall clock time %1.2f"%(_t1-_t0))

    print_passes(passes)

    p_id = 1

    t0, t1 = passes['t'][0][p_id]
    t = n.linspace(t0, t1, num=1000)

    scan_snr = get_scan_snr(t, o, radar)
    track_snr = get_track_snr(t, o, radar)

    fig = plt.figure(figsize=(15,15))
    ax = fig.add_subplot(211)
    ax = plot_snr(t, track_snr, radar, ax=ax)
    ax.set_title('SNR when tracking')

    ax = fig.add_subplot(212)
    ax = plot_snr(t, scan_snr, radar, ax=ax)
    ax.set_title('SNR when scanning')

    ts, angs = get_angles(passes, o, radar)
    ax = plot_angles(ts, angs)

    plt.show()