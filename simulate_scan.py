#!/usr/bin/env python

'''Simulate discovery observations with user-defined scan pattern.

# TODO: Describe module usage

'''

import numpy as n
import scipy.constants as c
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
import h5py
import time

# SORTS imports
import space_object as so
import coord
import debris
import plothelp
from radar_config import plot_radar_earth
import simulate_tracking
import dpt_tools as dpt


def pp_det(det_times):
    '''Function to pretty print detection times list returned by the :func:`simulate_scan.get_iods` function.
        
        :param list det_times: List of dictionaries generated by get_iods.
    '''
    for txi, tx_det in enumerate(det_times):
        det_n = len(tx_det['snr'])
        for i in range(det_n):
            snr_str = ''
            for rxi,snr_db in enumerate(10.0*n.log10(tx_det['snr'][i])):
                snr_str += 'RX-{}: {} db | '.format(rxi,snr_db)
            print('TX-{} Detection {} at {} h.\n Detection SNR: {}\n'.format(
                    txi,
                    i,
                    tx_det['tm'][i]/3600.0,
                    snr_str,
                )
            )



def get_detections(obj, radar, t0, t1, max_dpos=10.0e3, logger = None, pass_dt=None):
    '''Find all detections of a object by input radar between two times relative the object Epoch.

    :param SpaceObject obj: Space object to find detections of.
    :param RadarSystem radar: Radar system that scans for the object.
    :param float t0: Start time for scan relative space object epoch.
    :param float t1: End time for scan relative space object epoch.
    :param float max_dpos: Maximum separation between evaluation points in meters for finding the pass interval.
    :param Logger logger: Logger object for logging the execution of the function.
    :param float pass_dt: The time step used when evaluating pass. Default is the scan-minimum dwell time but can be forces to a setting by this variable.
    :return: Detections data structure in form of a list of dictionaries, see description below.
    :rtype: list
    
    **Return data:**
    
        List of same length as radar system TX antennas. Each entry in the list is a dictionary with the following items:

        * t0: List of pass start times. Length is equal the number of detection but unique times are equal to the number of passes..
        * t1: List of pass end times, i.e. when the space object passes below the FOV. Same list configuration as "t0"
        * snr: List of lists of SNR's for each TX-RX pair for each detection. I.e. the top list length is equal the number of detections and the elements are lists of length equal to the number of TX-RX pairs.
        * tm: List of times corresponding to each detection, same length as "snr" item.
        * range: Same structure as the "snr" item but with ranges between the TX and the RX antenna trough the object, i.e. two way range. Unit is meters.
        * range_rate: Same structure as the "range" item but with range-rates, i.e. rate of change of two way range. Unit is meters per second.
        * tx_gain: List of gains from the TX antenna for the detection, length of list is equal the number of detections.
        * rx_gain: List of lists in the same structure as the "snr" item but with receiver gains instead of signal to noise ratios.
        * on_axis_angle: List of angles between the space object and the pointing direction for each detection, length of list is equal to the number of detections.
    
    '''

    # list of transmitters
    txs = radar._tx
    # list of receivers
    rxs = radar._rx
    
    zenith = n.array([0,0,1], dtype=n.float)

    # list of detections for each transmitter-receiver pair
    # return detections, and also r, rr, tx gain, and rx gain
    detections=[]
    for tx in txs:
        detections.append({"t0":[],"t1":[],"snr":[],'tm':[], "range":[], "range_rate":[], "tx_gain":[], "rx_gain":[], "on_axis_angle":[]})
    
    num_t = simulate_tracking.find_linspace_num(t0, t1, obj.a*1e3, obj.e, max_dpos=max_dpos)
    
    if logger is not None:
        logger.debug("n_points {} at {} m resolution".format(num_t, max_dpos))

    # time vector
    t = n.linspace(t0, t1, num=num_t, dtype=n.float)
    
    passes, passes_id, _, _, _ = simulate_tracking.find_pass_interval(t, obj, radar)
    for txi, pas in enumerate(passes):
        if pas is None:
            passes[txi] = []
    for txi, pas in enumerate(passes_id):
        if pas is None:
            passes_id[txi] = []
    
    #format: passes
    # [tx num][pass num][0 = above, 1 = below]

    if logger is not None:
        for txi in range(len(txs)):
            logger.debug('passes cnt: {}'.format(len(passes[txi])))

    for txi, tx in enumerate(txs):
        
        for pas in passes[txi]:
            
            if pass_dt is None:
                num_pass = int((pas[1] - pas[0])/tx.scan.min_dwell_time)
            else:
                num_pass = int((pas[1] - pas[0])/pass_dt)
            
            t_pass = n.linspace(pas[0], pas[1], num=num_pass, dtype=n.float)
            
            if logger is not None:
                logger.debug('tx{} - pass{} - num_pass: {}'.format(txi,len(detections[txi]["t0"]),num_pass))
            
            states = obj.get_state(t_pass)
            
            ecef = states[:3,:]
            vels = states[3:,:]
            
            pos_rel_tx = (ecef.T-tx.ecef).T
            
            snrs = n.empty((num_pass, len(rxs)), dtype=n.float)
            angles = n.empty((num_pass, ), dtype=n.float)
            ks_obj = n.empty((3, num_pass), dtype=n.float)
            ksr_obj = n.empty((3, num_pass, len(rxs)), dtype=n.float)
            k0s = n.empty((3, num_pass), dtype=n.float)
            range_tx = n.empty((num_pass, ), dtype=n.float)
            vel_tx = n.empty((num_pass, ), dtype=n.float)
            gain_tx = n.empty((num_pass, ), dtype=n.float)
            gain_rx = n.empty((num_pass, len(rxs)), dtype=n.float)
            r_rad = n.empty((num_pass, len(rxs)), dtype=n.float)
            v_rad = n.empty((num_pass, len(rxs)), dtype=n.float)
            snrs_mask = n.full(snrs.shape, False, dtype=n.bool)
            zenith_mask = n.full(snrs.shape, False, dtype=n.bool)
            
            inds_mask = n.full((num_pass, ), True, dtype=n.bool)
            inds = n.arange(num_pass, dtype=n.int)
            
            for I in range(num_pass):
                k0 = tx.get_scan(t_pass[I]).local_pointing(t_pass[I])
                k0s[:, I] = k0
                
                ks_obj[:, I] = coord.ecef2local(
                    lat = tx.lat,
                    lon = tx.lon,
                    alt = tx.alt,
                    x = pos_rel_tx[0,I],
                    y = pos_rel_tx[1,I],
                    z = pos_rel_tx[2,I],
                )
                
                angles[I] = coord.angle_deg(k0s[:, I], ks_obj[:,I])
                if angles[I] > radar.max_on_axis:
                    inds_mask[I] = False
            
            inds_tmp = inds[inds_mask]
            
            if logger is not None:
                logger.debug('f1 inds left {}/{}'.format(inds_mask.shape, inds.shape))
            
            for rxi, rx in enumerate(rxs):
                pos_rel_rx = (ecef.T-rx.ecef).T
                
                for I in inds_tmp:
                    k_obj_rx = coord.ecef2local(
                        lat = rx.lat,
                        lon = rx.lon,
                        alt = rx.alt,
                        x = pos_rel_rx[0,I],
                        y = pos_rel_rx[1,I],
                        z = pos_rel_rx[2,I],
                    )
                    
                    ksr_obj[:, I, rxi] = k_obj_rx
                    
                    elevation_angle_rx = 90.0 - coord.angle_deg(zenith, k_obj_rx)
                    if elevation_angle_rx < rx.el_thresh:
                        continue
                    
                    zenith_mask[I, rxi] = True
                        
                    rx_dist = n.linalg.norm(pos_rel_rx[:,I])
                    rx_vel = n.dot( vels[:,I], pos_rel_rx[:,I]/rx_dist )
                    
                    r_rad[I, rxi] = rx_dist
                    v_rad[I, rxi] = rx_vel 


            for I in inds:
                if n.any(zenith_mask[I, :]):
                    tx.beam.point_k0(k0s[:, I])
                    range_tx[I] = n.linalg.norm(pos_rel_tx[:, I])
                    vel_tx[I] = n.dot( vels[:,I], pos_rel_tx[:,I]/range_tx[I] )
                    gain_tx[I] = tx.beam.gain(ks_obj[:, I])


            for rxi, rx in enumerate(rxs):
                if logger is not None:
                    logger.debug('f2_rx{} inds left {}/{}'.format(rxi, inds.shape, inds[zenith_mask[:, rxi]].shape))
                
                for I in inds[zenith_mask[:, rxi]]:
                    

                    # TODO: We need to change this
                    # Probably we need to define additional parameters in the RadarSystem class that defines the constraints on each receiver transmitter, and defines if any of them are at the same location.
                    # what we need to do is give the RX a scan also that describes the pointing for detections when there is no after the fact beam-steering to do grid searches
                    # 
                    if rx.phased:
                        # point receiver towards object (post event beam forming)
                        rx.beam.point_k0(ksr_obj[:, I, rxi])
                    else:
                        #point according to receive pointing
                        k0 = rx.get_scan(t_pass[I]).local_pointing(t_pass[I])
                        rx.beam.point_k0(k0)

                    gain_rx[I, rxi] = rx.beam.gain(ksr_obj[:, I, rxi])

                    snr = debris.hard_target_enr(
                        gain_tx[I],
                        gain_rx[I, rxi],
                        rx.wavelength,
                        tx.tx_power,
                        range_tx[I],
                        r_rad[I, rxi],
                        diameter_m=obj.d,
                        bandwidth=tx.coh_int_bandwidth,
                        rx_noise_temp=rx.rx_noise,
                    )
                    
                    #if logger is not None:
                    #    logger.debug('angles[{}] {} deg, gain_tx[{}] = {}, gain_rx[{}, {}] = {}'.format(
                    #        I, angles[I],
                    #        I, gain_tx[I],
                    #        I, rxi, gain_rx[I, rxi],
                    #    ))

                    snrs[I, rxi] = snr
                    
                    if snr < tx.enr_thresh:
                        continue
                    
                    snrs_mask[I, rxi] = True
                    
            
            for I in inds:
                if n.any(snrs_mask[I, :]):
                    inst_snrs = snrs[I, snrs_mask[I, :]]
                    if 10.0*n.log10(n.max(inst_snrs)) > radar.min_SNRdb:
                        if logger is not None:
                            logger.debug('adding detection at {} sec with {} SNR'.format(t_pass[I], snrs[I, :]))

                        detections[txi]["t0"].append(pas[0])
                        detections[txi]["t1"].append(pas[1])
                        detections[txi]["snr"].append( snrs[I, :] )
                        detections[txi]["range"].append( r_rad[I, :] + range_tx[I] )
                        detections[txi]["range_rate"].append( v_rad[I, :] + vel_tx[I] )
                        detections[txi]["tx_gain"].append( gain_tx[I] )
                        detections[txi]["rx_gain"].append( gain_rx[I, :] )
                        detections[txi]["tm"].append( t_pass[I] )
                        detections[txi]["on_axis_angle"].append( angles[I] )

    return detections
    



def plot_detections(detections, radar, space_o, t_range = 3600.0):
    '''Visualizes the detections made by a radar of a space object.

    '''
    figs = []
    for detection in detections:

        t = np.linspace(np.min(detection['tm']) - t_range, np.max(detection['tm']) + t_range, num=1000, dtype=np.float)

        passes = np.unique(np.array(detection['t0']))

        print('{} detections of object over {} passes'.format(len(detection['tm']), len(passes)))

        ecefs1 = space_o.get_state(t)

        fig = plt.figure(figsize=(15,15))
        ax = fig.add_subplot(111, projection='3d')
        plothelp.draw_earth_grid(ax)

        figs += [ (fig, ax) ]

        radar_scans.plot_radar_scan(radar._tx[0].scan, earth=True, ax=ax)

        ax.plot(ecefs1[0,:], ecefs1[1,:], ecefs1[2,:],"-",color="green", alpha=0.5)

        for det in detection['tm']:
            ecefs2 = space_o.get_state([det])
            ax.plot(ecefs2[0,:], ecefs2[1,:], ecefs2[2,:],".",color="red", alpha=0.5)
            ax.plot(
                [radar._tx[0].ecef[0], ecefs2[0,0]], 
                [radar._tx[0].ecef[1], ecefs2[1,0]], 
                [radar._tx[0].ecef[2], ecefs2[2,0]],
                "-",color="red", alpha=0.25,
            )


        box = 1000e3

        ax.set_xlim([radar._tx[0].ecef[0] - box, radar._tx[0].ecef[0] + box])
        ax.set_ylim([radar._tx[0].ecef[1] - box, radar._tx[0].ecef[1] + box])
        ax.set_zlim([radar._tx[0].ecef[2] - box, radar._tx[0].ecef[2] + box])

    return figs


def plot_scan_for_object(obj, radar, t0, t1, plot_full_scan=False):

    # list of transmitters
    txs = radar._tx
    # list of receivers
    rxs = radar._rx
    
    num_t = simulate_tracking.find_linspace_num(t0, t1, obj.a*1e3, obj.e, max_dpos=10e3)
    
    # time vector
    t = n.linspace(t0, t1, num=num_t, dtype=n.float)

    passes, _, _, _, _ = simulate_tracking.find_pass_interval(t, obj, radar)
    #format: passes
    # [tx num][pass num][0 = above, 1 = below]

    fig = plt.figure(figsize=(15,15))
    ax = fig.add_subplot(111, projection='3d')
    ax.grid(False)
    ax.view_init(15, 5)
    plothelp.draw_earth_grid(ax)
    plot_radar_earth(ax, radar)

    scan_range = 1200e3

    lab_done = False
    lab_done_so = False
    cycle_complete = False

    for txi, tx in enumerate(txs):
        
        for pas in passes[txi]:
            num_pass = int((pas[1] - pas[0])/tx.scan.min_dwell_time)
            t_pass = n.linspace(pas[0], pas[1], num=num_pass, dtype=n.float)

            ecefs = obj.get_orbit(t_pass)

            if lab_done_so:
                ax.plot(ecefs[0,:], ecefs[1,:], ecefs[2,:], '-k')
            else:
                lab_done_so = True
                ax.plot(ecefs[0,:], ecefs[1,:], ecefs[2,:], '-k', label='Space Object')

            for I in range(num_pass):
                scan = tx.get_scan(t_pass[I])
                if scan._scan_time is not None:
                    if t_pass[I] - pas[0] > scan._scan_time:
                        cycle_complete = True

                txp0, k0 = scan.antenna_pointing(t_pass[I])

                if not plot_full_scan:
                    if cycle_complete:
                        continue

                if lab_done:
                    ax.plot(
                        [txp0[0], txp0[0] + k0[0]*scan_range],
                        [txp0[1], txp0[1] + k0[1]*scan_range],
                        [txp0[2], txp0[2] + k0[2]*scan_range],
                        '-g',
                        alpha=0.2,
                    )
                else:
                    ax.plot(
                        [txp0[0], txp0[0] + k0[0]*scan_range],
                        [txp0[1], txp0[1] + k0[1]*scan_range],
                        [txp0[2], txp0[2] + k0[2]*scan_range],
                        '-g',
                        alpha=0.01,
                        label='Scan',
                    )
                    lab_done = True


    max_range = 1500e3

    ax.set_xlim(txs[0].ecef[0] - max_range, txs[0].ecef[0] + max_range)
    ax.set_ylim(txs[0].ecef[1] - max_range, txs[0].ecef[1] + max_range)
    ax.set_zlim(txs[0].ecef[2] - max_range, txs[0].ecef[2] + max_range)
    plt.legend()
    plt.show()




if __name__ == "__main__":
    import radar_library as rl
    from propagator_sgp4 import PropagatorSGP4
    import radar_scan_library as rslib
    import antenna_library as alib
    import logging_setup
    import logging
    
    t0 = time.time()
    
    #radar=rl.eiscat_3d(beam='array')
    radar=rl.eiscat_3d(beam='gauss')
    
    # get all detections for this space object
    obj = so.SpaceObject(
        a=7000,
        e=0.0,
        i=72,
        raan=0,
        aop=0,
        mu0=0,
        C_D=2.3,
        A=1.0,
        m=1.0,
        d=0.7,
        propagator = PropagatorSGP4,
        propagator_options = {
            'polar_motion': False
        },
    )
    print(obj)

    rs1 = rslib.ns_fence_model(0, 0, 0, min_el = 30, angle_step = 1, dwell_time = 0.1)
    rs2 = rslib.sph_rng_model(0, 0, 0, min_el = 30, dwell_time = 0.1)

    radar.set_scan(rs1)

    beam_tx = alib.e3d_array_beam_stage1_dense_interp(az0=0, el0=90.0, I_0=10**4.2)
    beam_rx = alib.e3d_array_beam_interp(az0=0, el0=90.0, I_0=10**4.5)
    radar.set_beam(beam_tx, 'TX')
    radar.set_beam(beam_rx, 'RX')


    #plot_scan_for_object(obj, radar, 0.0, 1.5*24.0*3600.0)

    #radar.set_scan(rs2)
    #plot_scan_for_object(obj, radar, 0.0, 12.0*3600.0)

    #exit()

    logger = logging_setup.setup_logging(
        term_level = logging.DEBUG,
        logfile = False,
    )

    det_times = get_detections(obj, radar, 0.0, 1.0*24.0*3600.0, logger=None)
    
    #print(det_times)

    total_dets = len(det_times[0]["snr"])
    print('total_dets: {}'.format(total_dets))

    if total_dets > 0:
        max_snr = n.max(det_times[0]["snr"])
        print('max_snr   : {} dB'.format(10*n.log10(max_snr)))

    #pp_det(det_times)
    
    t1=time.time()
    print("wall clock time %1.2f"%(t1-t0))
    

    
